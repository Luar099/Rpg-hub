<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Rounds — MORTE | Gravidade + Dificuldade</title>
  <style>
    :root{
      --bg:#05060a;
      --panel:rgba(15,18,32,.92);
      --line:rgba(255,255,255,.10);
      --txt:#f2f4ff;
      --muted:#a7adc2;
      --p1:#fb923c;   /* laranja */
      --p2:#60a5fa;   /* azul */
      --good:#22c55e;
      --bad:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1100px 700px at 55% 10%, rgba(96,165,250,.16), transparent 60%),
        radial-gradient(1000px 800px at 20% 90%, rgba(251,146,60,.12), transparent 60%),
        var(--bg);
      color:var(--txt);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .wrap{
      width:min(1260px, 100%);
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:14px;
    }
    @media (max-width: 1020px){
      .wrap{grid-template-columns:1fr}
    }
    .card{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .topbar{
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
      flex-wrap:wrap;
    }
    .title{display:flex; flex-direction:column; gap:2px;}
    .title b{font-size:14.5px; letter-spacing:.25px}
    .title span{font-size:12px; color:var(--muted)}
    .hud{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
      font-size:12px;
    }
    .pill{
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(255,255,255,.03);
      white-space:nowrap;
    }
    .pill strong{font-weight:850}
    .btn{
      cursor:pointer;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--txt);
      padding:8px 10px;
      border-radius:12px;
      font-weight:650;
    }
    .btn:hover{background: rgba(255,255,255,.10)}
    canvas{
      width:100%;
      height:700px;
      display:block;
      background:
        radial-gradient(1100px 700px at 50% 30%, rgba(255,255,255,.05), transparent 60%),
        #070815;
    }
    .side{padding:14px}
    .side h3{margin:0 0 8px 0; font-size:14px}
    .side p{margin:0 0 10px 0; color:var(--muted); font-size:12.5px; line-height:1.35}
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin:10px 0 12px 0;
    }
    .k{
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;
      background: rgba(255,255,255,.03);
    }
    .k .key{font-weight:900; font-size:14px}
    .k .desc{font-size:12px; color:var(--muted); margin-top:4px}
    .legend{
      border-top:1px dashed var(--line);
      padding-top:12px;
      margin-top:10px;
      display:flex; flex-direction:column; gap:6px;
      font-size:12.5px; color:var(--muted);
    }
    .dot{display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:8px; vertical-align:middle}

    .control{
      margin-top:10px;
      padding:10px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(255,255,255,.03);
    }
    .row{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;
      margin:8px 0;
    }
    select, input[type="range"]{
      width:100%;
      accent-color: #60a5fa;
    }
    select{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      color: var(--txt);
      outline:none;
    }
    .mini{
      font-size:12px; color:var(--muted);
    }
    .overlay{
      position:fixed; inset:0;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.58);
      backdrop-filter: blur(7px);
      padding:18px;
    }
    .overlay.show{display:flex}
    .modal{
      width:min(780px,100%);
      background: rgba(12,14,25,.95);
      border:1px solid var(--line);
      border-radius:20px;
      padding:18px;
      box-shadow: 0 26px 80px rgba(0,0,0,.65);
    }
    .modal h2{margin:0 0 8px 0; font-size:18px}
    .modal p{margin:0 0 12px 0; color:var(--muted); line-height:1.4}
    .modal .btnrow{display:flex; gap:10px; flex-wrap:wrap}
    .small{font-size:12px; color:var(--muted); margin-top:8px}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="topbar">
      <div class="title">
        <b>ROUNDS — A MORTE | Gravidade + Dificuldade</b>
        <span>3 vidas cada. Vence 3 rodadas (mata a Morte 3x) = RENASCE.</span>
      </div>
      <div class="hud">
        <span class="pill">Rodada: <strong id="round">1</strong>/3</span>
        <span class="pill">Vidas Você: <strong id="livesP">3</strong></span>
        <span class="pill">Vidas MORTE: <strong id="livesE">3</strong></span>
        <span class="pill">Dash: <strong id="dash">OK</strong></span>
        <button class="btn" id="btnStart">Iniciar</button>
        <button class="btn" id="btnPause">Pausar</button>
        <button class="btn" id="btnReset">Reset</button>
      </div>
    </div>
    <canvas id="c" width="1280" height="720"></canvas>
  </div>

  <div class="card side">
    <h3>Controles</h3>
    <div class="grid">
      <div class="k"><div class="key">A / D</div><div class="desc">Andar</div></div>
      <div class="k"><div class="key">W</div><div class="desc">Pular</div></div>
      <div class="k"><div class="key">Mouse</div><div class="desc">Mirar</div></div>
      <div class="k"><div class="key">Clique / Espaço</div><div class="desc">Atirar</div></div>
      <div class="k"><div class="key">Shift</div><div class="desc">Dash</div></div>
      <div class="k"><div class="key">Esc / R</div><div class="desc">Pausar / Reset</div></div>
    </div>

    <div class="control">
      <div class="row">
        <div><b>Dificuldade</b><div class="mini">muda a força da IA em tempo real</div></div>
      </div>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium" selected>Médio</option>
        <option value="hard">Hard</option>
        <option value="custom">Custom</option>
      </select>

      <div style="height:8px"></div>

      <div class="row">
        <div><b>Intensidade (Custom)</b><div class="mini">0 = easy • 100 = hard</div></div>
        <div class="pill"><strong id="intVal">50</strong></div>
      </div>
      <input id="intensity" type="range" min="0" max="100" value="50"/>

      <div class="mini" id="diffDesc" style="margin-top:8px">
        Médio: equilíbrio bom — a Morte te pressiona, mas dá espaço pra aprender.
      </div>
    </div>

    <p>
      Cair no vazio conta como morte. A dificuldade pode ser trocada sem resetar.
    </p>
    <div class="legend">
      <div><span class="dot" style="background:var(--p1)"></span>Você (laranja)</div>
      <div><span class="dot" style="background:var(--p2)"></span>A MORTE (azul)</div>
      <div><span class="dot" style="background:var(--good)"></span>Ganhe 3 rodadas = renasce</div>
      <div><span class="dot" style="background:var(--bad)"></span>Caiu no vazio = morreu</div>
    </div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="mTitle">Rounds — MORTE</h2>
    <p id="mText">Derrote a Morte 3 vezes para renascer.</p>
    <div class="btnrow">
      <button class="btn" id="mPlay">Jogar</button>
      <button class="btn" id="mReset">Reset</button>
      <button class="btn" id="mClose">Fechar</button>
    </div>
    <div class="small" id="mHint"></div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  // UI
  const $round = document.getElementById("round");
  const $lP = document.getElementById("livesP");
  const $lE = document.getElementById("livesE");
  const $dash = document.getElementById("dash");
  const btnStart = document.getElementById("btnStart");
  const btnPause = document.getElementById("btnPause");
  const btnReset = document.getElementById("btnReset");

  const selDiff = document.getElementById("difficulty");
  const rngInt = document.getElementById("intensity");
  const intVal = document.getElementById("intVal");
  const diffDesc = document.getElementById("diffDesc");

  const overlay = document.getElementById("overlay");
  const mTitle = document.getElementById("mTitle");
  const mText  = document.getElementById("mText");
  const mHint  = document.getElementById("mHint");
  const mPlay  = document.getElementById("mPlay");
  const mReset = document.getElementById("mReset");
  const mClose = document.getElementById("mClose");

  // ===== CONFIG BASE =====
  const MAX_ROUNDS = 3;
  const LIVES_PER_ROUND = 3;

  // physics (player)
  const R = 18;
  const GRAV = 1600;
  const MOVE_ACC = 2600;
  const MOVE_MAX = 320;
  const AIR_CONTROL = 0.65;
  const JUMP_V = 620;
  const GROUND_FRICTION = 0.82;
  const AIR_FRICTION = 0.98;

  // dash
  const DASH_CD = 1200;
  const DASH_TIME = 0.11;
  const DASH_V = 860;

  // shooting
  const BULLET_R = 5;
  const BULLET_SPEED = 620;
  const FIRE_CD = 200;
  const BULLET_LIFE = 1.4;
  const KNOCK = 320;

  // ===== WORLD =====
  const W = canvas.width;
  const H = canvas.height;

  const plats = [
    {x: 80,  y: H-90,  w: W-160, h: 26},
    {x: 180, y: H-210, w: 260, h: 22},
    {x: W-440, y: H-210, w: 260, h: 22},
    {x: W/2 - 150, y: H-330, w: 300, h: 22},
    {x: 110, y: H-380, w: 220, h: 20},
    {x: W-330, y: H-380, w: 220, h: 20},
    {x: W/2 - 360, y: H-280, w: 160, h: 18},
    {x: W/2 + 200, y: H-280, w: 160, h: 18},
  ];

  // ===== DIFFICULTY (Adjustable) =====
  // These values get updated by setDifficulty()
  const AI = {
    eMoveMax: 240,
    reaction: 0.10,
    fireChance: 0.55,
    aimWobble: 26,
    dashChance: 0.007,
    desiredDist: 300,
    pressure: 0.55,  // 0..1 (how much it tries to chase)
  };

  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function applyPreset(mode){
    // presets
    if (mode==="easy"){
      rngInt.value = 25;
      setCustom(25);
      diffDesc.textContent = "Easy: a Morte é lenta e erra bastante. Ótimo pra aprender.";
    } else if (mode==="medium"){
      rngInt.value = 50;
      setCustom(50);
      diffDesc.textContent = "Médio: equilíbrio bom — te pressiona, mas dá espaço pra reagir.";
    } else if (mode==="hard"){
      rngInt.value = 85;
      setCustom(85);
      diffDesc.textContent = "Hard: a Morte fica bem agressiva e mira melhor.";
    } else {
      // custom mantém slider
      setCustom(parseInt(rngInt.value,10));
      diffDesc.textContent = "Custom: você decide o quanto a Morte aperta.";
    }
  }

  function setCustom(intensity){
    // intensity: 0..100
    const t = clamp(intensity/100, 0, 1);

    // easy -> hard ranges
    AI.eMoveMax   = lerp(200, 310, t);
    AI.reaction   = lerp(0.16, 0.040, t);  // smaller = faster react
    AI.fireChance = lerp(0.30, 0.85, t);
    AI.aimWobble  = lerp(44, 10, t);       // lower wobble = better aim
    AI.dashChance = lerp(0.003, 0.020, t);
    AI.desiredDist= lerp(340, 240, t);
    AI.pressure   = lerp(0.40, 0.85, t);

    intVal.textContent = String(intensity);
  }

  selDiff.addEventListener("change", () => applyPreset(selDiff.value));
  rngInt.addEventListener("input", () => {
    intVal.textContent = rngInt.value;
    selDiff.value = "custom";
    applyPreset("custom");
  });

  // ===== STATE =====
  let running=false, paused=false, lastT=0;
  let round=1, livesP=LIVES_PER_ROUND, livesE=LIVES_PER_ROUND, kills=0;

  const keys = Object.create(null);
  let mouse = {x: W/2, y: H/2, down:false};
  const bullets = []; // {x,y,vx,vy,life,from}

  const player = {
    x: 220, y: H-200,
    vx: 0, vy: 0,
    onGround:false,
    coyote:0,
    dashCD:0, dashT:0,
    fireCD:0,
  };

  const enemy = {
    x: W-220, y: H-200,
    vx: 0, vy: 0,
    onGround:false,
    coyote:0,
    dashCD:0, dashT:0,
    fireCD:0,
    aimX: 220, aimY: H-200
  };

  function showOverlay(title,text,hint=""){
    mTitle.textContent=title;
    mText.textContent=text;
    mHint.textContent=hint;
    overlay.classList.add("show");
  }
  function hideOverlay(){ overlay.classList.remove("show"); }

  function updateHUD(){
    $round.textContent=round;
    $lP.textContent=livesP;
    $lE.textContent=livesE;
    $dash.textContent=(player.dashCD<=0 ? "OK" : (Math.ceil(player.dashCD/100)/10)+"s");
  }

  function resetPositions(){
    player.x=220; player.y=H-200; player.vx=0; player.vy=0; player.onGround=false; player.coyote=0;
    player.dashT=0; player.fireCD=0;
    enemy.x=W-220; enemy.y=H-200; enemy.vx=0; enemy.vy=0; enemy.onGround=false; enemy.coyote=0;
    enemy.dashT=0; enemy.fireCD=0;
    enemy.aimX=player.x; enemy.aimY=player.y;
    bullets.length=0;
  }
  function resetGame(){
    running=false; paused=false;
    round=1; kills=0;
    livesP=LIVES_PER_ROUND; livesE=LIVES_PER_ROUND;
    resetPositions();
    updateHUD();
  }

  // ===== COLLISION =====
  function resolvePlatforms(ent){
    ent.onGround=false;

    // clamp in world horizontally
    ent.x = clamp(ent.x, R, W-R);

    for (const p of plats){
      const closestX = clamp(ent.x, p.x, p.x+p.w);
      const closestY = clamp(ent.y, p.y, p.y+p.h);
      const dx = ent.x - closestX;
      const dy = ent.y - closestY;
      if (dx*dx + dy*dy > R*R) continue;

      const topDist = Math.abs((ent.y + R) - p.y);
      const bottomDist = Math.abs((p.y+p.h) - (ent.y - R));

      if (ent.vy >= 0 && topDist < 30 && ent.y < p.y){
        ent.y = p.y - R - 0.01;
        ent.vy = 0;
        ent.onGround = true;
        ent.coyote = 0.10;
      } else if (ent.vy < 0 && bottomDist < 30 && ent.y > p.y){
        ent.y = p.y + p.h + R + 0.01;
        ent.vy = 70;
      } else {
        if (ent.x < p.x) ent.x = p.x - R - 0.01;
        else if (ent.x > p.x+p.w) ent.x = p.x+p.w + R + 0.01;
        ent.vx *= -0.35;
      }
    }
  }

  // ===== SHOOTING =====
  function shoot(from){
    const ent = (from==="P") ? player : enemy;
    if (ent.fireCD>0) return;

    let tx, ty;
    if (from==="P"){ tx=mouse.x; ty=mouse.y; }
    else { tx=enemy.aimX; ty=enemy.aimY; }

    const dx = tx - ent.x;
    const dy = ty - ent.y;
    const d = Math.max(1, Math.hypot(dx,dy));
    const vx = (dx/d)*BULLET_SPEED;
    const vy = (dy/d)*BULLET_SPEED;

    bullets.push({
      x: ent.x + (dx/d)*(R+10),
      y: ent.y + (dy/d)*(R+10),
      vx, vy,
      life: BULLET_LIFE,
      from
    });

    ent.fireCD = FIRE_CD;
  }

  function bulletHits(ent, b){
    const dx = b.x - ent.x, dy = b.y - ent.y;
    const rr = (R + BULLET_R);
    return dx*dx + dy*dy <= rr*rr;
  }

  function killPlayer(){
    livesP--;
    updateHUD();
    if (livesP<=0){
      paused=true;
      showOverlay("Derrotado", "Você perdeu as 3 vidas desta rodada. Tente novamente.",
        "Dica: troque a dificuldade no menu e volte.");
      livesP=LIVES_PER_ROUND; livesE=LIVES_PER_ROUND;
      resetPositions();
      updateHUD();
    } else {
      resetPositions();
    }
  }

  function killEnemy(){
    livesE--;
    updateHUD();
    if (livesE<=0){
      kills++;
      if (kills>=MAX_ROUNDS){
        paused=true;
        showOverlay("RENASCIDO!", "Você derrotou a MORTE 3 vezes. Você voltou.",
          "No RPG: descreva o retorno e uma marca/consequência.");
        return;
      }
      round = kills+1;
      livesP=LIVES_PER_ROUND; livesE=LIVES_PER_ROUND;
      resetPositions();
      updateHUD();
      paused=true;
      showOverlay(`Rodada ${round}/3`, "A MORTE retorna… você está mais perto do renascimento.",
        "Clique em Jogar para continuar.");
    } else {
      resetPositions();
    }
  }

  // ===== INPUT =====
  window.addEventListener("keydown",(e)=>{
    if (e.repeat) return;
    keys[e.code]=true;

    if (e.code==="Escape"){
      if(!running) return;
      paused=!paused;
      if(!paused){ lastT=performance.now(); requestAnimationFrame(loop); }
    }
    if (e.code==="Space"){
      e.preventDefault();
      if (!running) start();
      else if(!paused) shoot("P");
    }
    if (e.code==="KeyR"){
      hideOverlay();
      resetGame();
      draw();
    }
    if (e.code==="ShiftLeft"||e.code==="ShiftRight"){
      if(!running||paused) return;
      if (player.dashCD<=0){
        player.dashT = DASH_TIME;
        const dx = (mouse.x - player.x), dy = (mouse.y - player.y);
        const d = Math.max(1, Math.hypot(dx,dy));
        player.vx = (dx/d)*DASH_V;
        player.vy = (dy/d)*DASH_V*0.35;
      }
    }
    if (e.code==="KeyW"){
      if(!running||paused) return;
      if (player.onGround || player.coyote>0){
        player.vy = -JUMP_V;
        player.onGround=false;
        player.coyote=0;
      }
    }
  });
  window.addEventListener("keyup",(e)=> keys[e.code]=false);

  canvas.addEventListener("mousemove",(e)=>{
    const r=canvas.getBoundingClientRect();
    mouse.x = (e.clientX-r.left)*(W/r.width);
    mouse.y = (e.clientY-r.top)*(H/r.height);
  });
  canvas.addEventListener("mousedown",()=>{ mouse.down=true; if(running&&!paused) shoot("P");});
  window.addEventListener("mouseup",()=> mouse.down=false);

  // buttons
  btnStart.addEventListener("click", ()=>{ hideOverlay(); start(); });
  btnPause.addEventListener("click", ()=>{
    if(!running) return;
    paused=!paused;
    if(!paused){ lastT=performance.now(); requestAnimationFrame(loop); }
  });
  btnReset.addEventListener("click", ()=>{ hideOverlay(); resetGame(); draw(); });

  mPlay.addEventListener("click", ()=>{ hideOverlay(); if(!running) start(); else {paused=false; lastT=performance.now(); requestAnimationFrame(loop);} });
  mReset.addEventListener("click", ()=>{ hideOverlay(); resetGame(); draw(); });
  mClose.addEventListener("click", ()=> hideOverlay());
  overlay.addEventListener("click",(e)=>{ if(e.target===overlay) hideOverlay(); });

  function start(){
    if(!running){
      running=true; paused=false;
      lastT=performance.now();
      requestAnimationFrame(loop);
    } else {
      paused=false;
      lastT=performance.now();
      requestAnimationFrame(loop);
    }
  }

  // ===== UPDATE =====
  function update(dt){
    // cooldowns
    player.fireCD = Math.max(0, player.fireCD - dt*1000);
    enemy.fireCD  = Math.max(0, enemy.fireCD  - dt*1000);
    player.dashCD = Math.max(0, player.dashCD - dt*1000);
    enemy.dashCD  = Math.max(0, enemy.dashCD  - dt*1000);

    if (player.dashT>0){
      player.dashT -= dt;
      if(player.dashT<=0){ player.dashT=0; player.dashCD=DASH_CD; }
    }
    if (enemy.dashT>0){
      enemy.dashT -= dt;
      if(enemy.dashT<=0){ enemy.dashT=0; enemy.dashCD=DASH_CD; }
    }

    // coyote
    player.coyote = Math.max(0, player.coyote - dt);
    enemy.coyote  = Math.max(0, enemy.coyote  - dt);

    // ----- PLAYER -----
    let input = 0;
    if (keys["KeyA"]) input -= 1;
    if (keys["KeyD"]) input += 1;

    const control = player.onGround ? 1 : AIR_CONTROL;
    player.vx += input * MOVE_ACC * control * dt;
    player.vx = clamp(player.vx, -MOVE_MAX, MOVE_MAX);
    player.vx *= (player.onGround ? GROUND_FRICTION : AIR_FRICTION);

    player.vy += GRAV * dt;
    player.y += player.vy * dt;
    player.x += player.vx * dt;
    resolvePlatforms(player);

    // ----- ENEMY AI (adjustable) -----
    // aim with reaction speed
    const rx = 1 - Math.pow(AI.reaction, dt*60);
    enemy.aimX += (player.x - enemy.aimX) * rx;
    enemy.aimY += (player.y - enemy.aimY) * rx;

    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const dist = Math.max(1, Math.hypot(dx,dy));

    // horizontal movement: chase/retreat based on distance + "pressure"
    const desired = AI.desiredDist;
    let ei = 0;
    if (dist > desired) ei = (dx>0) ? 1 : -1;
    if (dist < desired*0.62) ei = (dx>0) ? -1 : 1;

    // soften: pressure controls how much it commits
    if (Math.random() > AI.pressure) ei *= 0.6;

    // jump if player above (chance scales a bit with pressure)
    if ((player.y < enemy.y - 90) && (enemy.onGround || enemy.coyote>0) && Math.random() < (0.007 + AI.pressure*0.006)){
      enemy.vy = -JUMP_V*0.92;
      enemy.onGround=false;
      enemy.coyote=0;
    }

    // dash sometimes
    if (enemy.dashCD<=0 && enemy.dashT<=0 && Math.random() < AI.dashChance){
      enemy.dashT = DASH_TIME;
      enemy.vx = Math.sign(dx||1) * DASH_V*(0.55 + AI.pressure*0.35);
      enemy.vy = -80;
    }

    enemy.vx += ei * MOVE_ACC * (0.52 + AI.pressure*0.20) * dt;
    enemy.vx = clamp(enemy.vx, -AI.eMoveMax, AI.eMoveMax);
    enemy.vx *= (enemy.onGround ? GROUND_FRICTION : AIR_FRICTION);

    enemy.vy += GRAV * dt;
    enemy.y += enemy.vy * dt;
    enemy.x += enemy.vx * dt;
    resolvePlatforms(enemy);

    // shoot chance + wobble
    if (enemy.fireCD<=0 && dist < 720 && Math.random() < AI.fireChance){
      const wobX = (Math.random()*2-1)*AI.aimWobble;
      const wobY = (Math.random()*2-1)*AI.aimWobble;
      enemy.aimX += wobX;
      enemy.aimY += wobY;
      shoot("E");
    }

    // ----- BULLETS -----
    for (let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;

      if (b.x < -50 || b.x > W+50 || b.y < -80 || b.y > H+120 || b.life<=0){
        bullets.splice(i,1);
        continue;
      }

      // hit platforms
      let hitPlat=false;
      for (const p of plats){
        if (b.x>=p.x && b.x<=p.x+p.w && b.y>=p.y && b.y<=p.y+p.h){ hitPlat=true; break; }
      }
      if (hitPlat){ bullets.splice(i,1); continue; }

      // hit entities
      if (b.from==="E"){
        if (bulletHits(player,b)){
          const kx = (player.x - b.x), ky = (player.y - b.y);
          const d = Math.max(1, Math.hypot(kx,ky));
          player.vx += (kx/d)*KNOCK*0.30;
          player.vy += (ky/d)*KNOCK*0.18;
          bullets.splice(i,1);
          killPlayer();
          continue;
        }
      } else {
        if (bulletHits(enemy,b)){
          const kx = (enemy.x - b.x), ky = (enemy.y - b.y);
          const d = Math.max(1, Math.hypot(kx,ky));
          enemy.vx += (kx/d)*KNOCK*0.30;
          enemy.vy += (ky/d)*KNOCK*0.18;
          bullets.splice(i,1);
          killEnemy();
          continue;
        }
      }
    }

    // fall deaths
    if (player.y > H + 140) killPlayer();
    if (enemy.y > H + 140) killEnemy();

    updateHUD();
  }

  // ===== DRAW =====
  function draw(){
    ctx.fillStyle="#070815";
    ctx.fillRect(0,0,W,H);

    // platforms
    for (const p of plats){
      ctx.fillStyle="rgba(255,255,255,0.06)";
      ctx.fillRect(p.x,p.y,p.w,p.h);
      ctx.strokeStyle="rgba(255,255,255,0.12)";
      ctx.strokeRect(p.x,p.y,p.w,p.h);
    }

    // crosshair
    if (running){
      ctx.beginPath();
      ctx.arc(mouse.x, mouse.y, 6, 0, Math.PI*2);
      ctx.fillStyle="rgba(242,244,255,0.9)";
      ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,0.25)";
      ctx.stroke();
    }

    // bullets
    for (const b of bullets){
      ctx.beginPath();
      ctx.arc(b.x,b.y,BULLET_R,0,Math.PI*2);
      ctx.fillStyle = (b.from==="P") ? "rgba(251,146,60,0.95)" : "rgba(96,165,250,0.95)";
      ctx.fill();
    }

    // balls
    drawBall(player.x,player.y,R,"rgba(251,146,60,0.95)","VOCÊ");
    drawBall(enemy.x,enemy.y,R,"rgba(96,165,250,0.95)","MORTE");

    // pause text
    if (!running){
      text("CLIQUE EM INICIAR", W/2, H/2-10, 34, "rgba(242,244,255,0.92)");
      text("A/D anda • W pula • Mouse mira • Clique/Espaço atira • Shift dash", W/2, H/2+28, 14, "rgba(167,173,194,0.95)");
    } else if (paused){
      text("PAUSADO", W/2, H/2-10, 34, "rgba(242,244,255,0.92)");
      text("Pressione Esc para voltar", W/2, H/2+28, 14, "rgba(167,173,194,0.95)");
    }

    // progress kills
    const bw=280,bh=10,pad=18;
    const bx = W - pad - bw;
    const by = pad + 10;
    ctx.fillStyle="rgba(255,255,255,0.08)";
    ctx.fillRect(bx,by,bw,bh);
    const pr = clamp(kills/MAX_ROUNDS,0,1);
    ctx.fillStyle="rgba(34,197,94,0.55)";
    ctx.fillRect(bx,by,bw*pr,bh);
    ctx.strokeStyle="rgba(255,255,255,0.12)";
    ctx.strokeRect(bx,by,bw,bh);
    ctx.font="700 12px system-ui";
    ctx.textAlign="left";
    ctx.textBaseline="bottom";
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.fillText("Renascimento", bx, by-3);

    // difficulty label
    ctx.font="700 12px system-ui";
    ctx.textAlign="left";
    ctx.textBaseline="bottom";
    ctx.fillStyle="rgba(255,255,255,0.65)";
    ctx.fillText(`Dificuldade: ${selDiff.value.toUpperCase()} (${rngInt.value})`, 18, 22);
  }

  function drawBall(x,y,r,color,label){
    ctx.beginPath();
    ctx.arc(x,y,r+11,0,Math.PI*2);
    ctx.fillStyle = color.replace("0.95","0.12");
    ctx.fill();

    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fillStyle=color;
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(255,255,255,0.22)";
    ctx.stroke();

    ctx.font="800 11px system-ui";
    ctx.textAlign="center";
    ctx.textBaseline="top";
    ctx.fillStyle="rgba(242,244,255,0.92)";
    ctx.fillText(label, x, y+r+8);
  }

  function text(t,x,y,size,color){
    ctx.font=`900 ${size}px system-ui`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillStyle=color;
    ctx.fillText(t,x,y);
  }

  function loop(t){
    if(!running) return;
    const dt = Math.min((t-lastT)/1000, 0.033);
    lastT = t;
    if(!paused) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ===== INIT =====
  applyPreset("medium");
  resetGame();
  draw();
  showOverlay(
    "ROUNDS — MORTE (com dificuldade)",
    "Escolha Easy / Médio / Hard (ou Custom) e derrote a Morte 3 vezes para renascer.",
    "Dica: se ficar puxado, abaixa a intensidade."
  );

  function startFromOverlay(){
    hideOverlay();
    if(!running){
      running=true; paused=false;
      lastT=performance.now();
      requestAnimationFrame(loop);
    } else {
      paused=false;
      lastT=performance.now();
      requestAnimationFrame(loop);
    }
  }
  btnStart.addEventListener("click", startFromOverlay);
  mPlay.addEventListener("click", startFromOverlay);
})();
</script>
</body>
</html>
